(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{299:function(s,t,a){"use strict";a.r(t);var r=a(1),e=Object(r.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"css-模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css-模块化"}},[s._v("#")]),s._v(" CSS 模块化")]),s._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#_1-命名约定"}},[s._v("1.命名约定")])]),a("li",[a("a",{attrs:{href:"#_2-css-in-js"}},[s._v("2.CSS in JS")])]),a("li",[a("a",{attrs:{href:"#_3-使用-js-来管理样式"}},[s._v("3.使用 JS 来管理样式")])])])]),a("p"),s._v(" "),a("p",[s._v("CSS 的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。于是，亟待解决的就是样式污染的问题。一般地，为了解决冲突，会把 class 命名写长一点，降低冲突几率；加上父元素的选择器，来限制范围等。 CSS 模块化就是来解决这个问题的，一般地，分为三类：")]),s._v(" "),a("h2",{attrs:{id:"_1-命名约定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-命名约定"}},[s._v("#")]),s._v(" 1.命名约定")]),s._v(" "),a("p",[s._v("该类 CSS 模块化方案主要用来规范 CSS命名，最常见的是 BEM、OOCSS 等，在构建工具出现之前，大多数都是在 CSS 命名上做文章。")]),s._v(" "),a("h2",{attrs:{id:"_2-css-in-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-css-in-js"}},[s._v("#")]),s._v(" 2.CSS in JS")]),s._v(" "),a("p",[s._v("彻底抛弃 CSS，用 javascript 来写 CSS 规则，常见的有 styled-components。")]),s._v(" "),a("h2",{attrs:{id:"_3-使用-js-来管理样式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用-js-来管理样式"}},[s._v("#")]),s._v(" 3.使用 JS 来管理样式")]),s._v(" "),a("p",[s._v("使用 JS 编译原生的 CSS 文件，使其具备模块化的能力，最常见的就是 CSS Modules。")])])}),[],!1,null,null,null);t.default=e.exports}}]);